import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost/esa";

export interface FetchArgs {
    url: string;
    options: any; 
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface BookmarkFixedDto extends BookmarkLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}

export interface BookmarkLocationDto {
}

export interface BookmarkReflowDto extends BookmarkLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}

export interface BookmarkRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": BookmarkLocationDto;
    /**
     * Text value
     */
    "text": string;
}

export interface BookmarkResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": BookmarkLocationDto;
    /**
     * Text value
     */
    "text": string;
}

export interface ContentLocationDto {
    /**
     * Resource id, the same value as contentId
     */
    "resourceId": string;
}

export interface EmpiriaContentRequest extends GeneratedContentRequest {
    /**
     * Text value
     */
    "text": string;
    "location": ContentLocationDto;
}

export interface EmpiriaContentResponse extends GeneratedContentResponse {
    /**
     * Text value
     */
    "text": string;
    "location": ContentLocationDto;
}

export interface EmpiriaHotspotRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": HotspotLocationDto;
    /**
     * Content value
     */
    "content": string;
}

export interface EmpiriaHotspotResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": HotspotLocationDto;
    /**
     * Content value
     */
    "content": string;
}

export interface GeneratedContentRequest {
    "location": Location;
    /**
     * Content type: bookmark, html content, html hotspot, text field, last visited page, teacher panel, note, empiria content, empiria hotspot, highlight
     */
    "type": string;
    /**
     * Resource ID
     */
    "resourceId": string;
}

export interface GeneratedContentResponse {
    /**
     * Unique UGC ID
     */
    "id": string;
    /**
     * User ID
     */
    "userId": string;
    /**
     * Last modification date-time
     */
    "modificationDate"?: Date;
    "location": Location;
    /**
     * Content type: bookmark, html content, html hotspot, text field, last visited page, teacher panel, note, empiria content, empiria hotspot, highlight
     */
    "type": string;
    /**
     * Resource ID
     */
    "resourceId": string;
}

export interface HighlightFixedDto extends HighlightLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
    /**
     * Highlight starting index
     */
    "startIndex": number;
    /**
     * Highlight ending index
     */
    "endIndex": number;
}

export interface HighlightLocationDto {
}

export interface HighlightReflowDto extends HighlightLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Paragraph location
     */
    "paragraphPosition": number;
    /**
     * Highlight starting index
     */
    "startIndex": number;
    /**
     * Highlight ending index
     */
    "endIndex": number;
}

export interface HighlightRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": HighlightLocationDto;
}

export interface HighlightResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": HighlightLocationDto;
}

export interface HotspotLocationDto {
    /**
     * Hotspot ID
     */
    "hotspotId": string;
}

export interface HtmlContentRequest extends GeneratedContentRequest {
    /**
     * Text value
     */
    "text": string;
    "location": ContentLocationDto;
}

export interface HtmlContentResponse extends GeneratedContentResponse {
    /**
     * Text value
     */
    "text": string;
    "location": ContentLocationDto;
}

export interface HtmlHotspotRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": HotspotLocationDto;
    /**
     * Content value
     */
    "content": string;
}

export interface HtmlHotspotResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": HotspotLocationDto;
    /**
     * Content value
     */
    "content": string;
}

export interface LastVisitedPageFixedDto extends LastVisitedPageLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}

export interface LastVisitedPageLocationDto {
}

export interface LastVisitedPageReflowDto extends LastVisitedPageLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}

export interface LastVisitedPageRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": LastVisitedPageLocationDto;
}

export interface LastVisitedPageResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": LastVisitedPageLocationDto;
}

export interface Location {
}

export interface NoteFixedDto extends NoteLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
    /**
     * X position on the page
     */
    "x": number;
    /**
     * Y position on the page
     */
    "y": number;
}

export interface NoteLocationDto {
}

export interface NoteReflowDto extends NoteLocationDto {
    "paragraph"?: any;
    /**
     * Char position where note should be displayed
     */
    "charPosition": number;
    /**
     * Type of location
     */
    "type": string;
}

export interface NoteRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": NoteLocationDto;
    /**
     * Content value
     */
    "text": string;
    /**
     * Text colour
     */
    "colour": NoteRequestColourEnum;
    /**
     * Text style
     */
    "textStyle": NoteRequestTextStyleEnum;
}

export type NoteRequestColourEnum = "WHITE" | "BLACK" | "GREEN" | "BLUE" | "RED" | "YELLOW" | "PINK" | "VIOLET";
export type NoteRequestTextStyleEnum = "BOLD" | "ITALIC" | "UNDERGROUND";
export interface NoteResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": NoteLocationDto;
    /**
     * Content value
     */
    "text": string;
    /**
     * Text colour
     */
    "colour": NoteResponseColourEnum;
    /**
     * Text style
     */
    "textStyle": NoteResponseTextStyleEnum;
}

export type NoteResponseColourEnum = "WHITE" | "BLACK" | "GREEN" | "BLUE" | "RED" | "YELLOW" | "PINK" | "VIOLET";
export type NoteResponseTextStyleEnum = "BOLD" | "ITALIC" | "UNDERGROUND";
export interface PointDto {
    /**
     * X position
     */
    "x": number;
    /**
     * Y position
     */
    "y": number;
}

export interface TeacherPanelContentDto {
    /**
     * Tool name
     */
    "toolName": TeacherPanelContentDtoToolNameEnum;
    /**
     * Shape points
     */
    "points": Array<PointDto>;
    /**
     * Transformation matrix
     */
    "transform": { [key: string]: string; };
    /**
     * Fill color
     */
    "fillColor": TeacherPanelContentDtoFillColorEnum;
    /**
     * Line color
     */
    "lineColor": TeacherPanelContentDtoLineColorEnum;
    /**
     * Line weight
     */
    "lineWeight": number;
    /**
     * Alpha
     */
    "alpha": number;
    /**
     * Contour
     */
    "contour"?: TeacherPanelContentDtoContourEnum;
}

export type TeacherPanelContentDtoToolNameEnum = "ELLIPSE" | "MARK" | "PEN" | "SHADE" | "TRIANGLE" | "LINE" | "MARKER" | "RECTANGLE" | "ARROW";
export type TeacherPanelContentDtoFillColorEnum = "WHITE" | "BLACK" | "GREEN" | "BLUE" | "RED" | "YELLOW" | "PINK" | "VIOLET";
export type TeacherPanelContentDtoLineColorEnum = "WHITE" | "BLACK" | "GREEN" | "BLUE" | "RED" | "YELLOW" | "PINK" | "VIOLET";
export type TeacherPanelContentDtoContourEnum = "FILL" | "OUTLINE";
export interface TeacherPanelFixedDto extends TeacherPanelLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}

export interface TeacherPanelLocationDto {
}

export interface TeacherPanelReflowDto extends TeacherPanelLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}

export interface TeacherPanelRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": TeacherPanelLocationDto;
    /**
     * Content value
     */
    "content": Array<TeacherPanelContentDto>;
}

export interface TeacherPanelResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": TeacherPanelLocationDto;
    /**
     * Content value
     */
    "content": Array<TeacherPanelContentDto>;
}

export interface TextfieldLocationDto {
    /**
     * Hotspot ID
     */
    "hotspotId": string;
}

export interface TextfieldRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": TextfieldLocationDto;
    /**
     * Text value
     */
    "text": string;
}

export interface TextfieldResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": TextfieldLocationDto;
    /**
     * Text value
     */
    "text": string;
}



/**
 * DefaultApi - fetch parameter creator
 */
export const DefaultApiFetchParamCreactor = {
    /** 
     * Create new user generated content
     * Save user generated content.
     * @param body Generated content object
     */
    createUGC(params: {  body: GeneratedContentRequest; }): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createUGC");
        }
        const baseUrl = `/ugc/ugc`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get user generated content by resource ID
     * Method returns the user generated content by resource id.
     * @param resourceId Resource ID
     */
    findUGC(params: {  resourceId?: string; }): FetchArgs {
        const baseUrl = `/ugc/ugc`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "resourceId": params.resourceId,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get types of user generated content.
     * Method returns types of user generated content.
     */
    getContentTypes(): FetchArgs {
        const baseUrl = `/ugc/type/ugc`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get location types of user generated content.
     * Method returns location types of user generated content.
     */
    getLocationTypes(): FetchArgs {
        const baseUrl = `/ugc/type/location`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get user generated content by UGC ID
     * Method returns the user generated content by UGC id.
     * @param ugcId UGC ID
     */
    getUGC(params: {  ugcId: string; }): FetchArgs {
        // verify required parameter "ugcId" is set
        if (params["ugcId"] == null) {
            throw new Error("Missing required parameter ugcId when calling getUGC");
        }
        const baseUrl = `/ugc/ugc/{ugcId}`
            .replace(`{${"ugcId"}}`, `${ params.ugcId }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Remove user generated content
     * Remove user generated content by UGC ID.
     * @param ugcId UGC ID
     */
    removeUGC(params: {  ugcId: string; }): FetchArgs {
        // verify required parameter "ugcId" is set
        if (params["ugcId"] == null) {
            throw new Error("Missing required parameter ugcId when calling removeUGC");
        }
        const baseUrl = `/ugc/ugc/{ugcId}`
            .replace(`{${"ugcId"}}`, `${ params.ugcId }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update user generated content
     * Update user generated content by UGC ID.
     * @param ugcId UGC ID
     * @param body Generated content object
     */
    updateUGC(params: {  ugcId: string; body: GeneratedContentRequest; }): FetchArgs {
        // verify required parameter "ugcId" is set
        if (params["ugcId"] == null) {
            throw new Error("Missing required parameter ugcId when calling updateUGC");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateUGC");
        }
        const baseUrl = `/ugc/ugc/{ugcId}`
            .replace(`{${"ugcId"}}`, `${ params.ugcId }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = {
    /** 
     * Create new user generated content
     * Save user generated content.
     * @param body Generated content object
     */
    createUGC(params: { body: GeneratedContentRequest;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DefaultApiFetchParamCreactor.createUGC(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get user generated content by resource ID
     * Method returns the user generated content by resource id.
     * @param resourceId Resource ID
     */
    findUGC(params: { resourceId?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<GeneratedContentResponse>> {
        const fetchArgs = DefaultApiFetchParamCreactor.findUGC(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get types of user generated content.
     * Method returns types of user generated content.
     */
    getContentTypes(): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = DefaultApiFetchParamCreactor.getContentTypes();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get location types of user generated content.
     * Method returns location types of user generated content.
     */
    getLocationTypes(): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = DefaultApiFetchParamCreactor.getLocationTypes();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get user generated content by UGC ID
     * Method returns the user generated content by UGC id.
     * @param ugcId UGC ID
     */
    getUGC(params: { ugcId: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<GeneratedContentResponse> {
        const fetchArgs = DefaultApiFetchParamCreactor.getUGC(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Remove user generated content
     * Remove user generated content by UGC ID.
     * @param ugcId UGC ID
     */
    removeUGC(params: { ugcId: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DefaultApiFetchParamCreactor.removeUGC(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update user generated content
     * Update user generated content by UGC ID.
     * @param ugcId UGC ID
     * @param body Generated content object
     */
    updateUGC(params: { ugcId: string; body: GeneratedContentRequest;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DefaultApiFetchParamCreactor.updateUGC(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /** 
     * Create new user generated content
     * Save user generated content.
     * @param body Generated content object
     */
    createUGC(params: {  body: GeneratedContentRequest; }) {
        return DefaultApiFp.createUGC(params)(this.fetch, this.basePath);
    }
    /** 
     * Get user generated content by resource ID
     * Method returns the user generated content by resource id.
     * @param resourceId Resource ID
     */
    findUGC(params: {  resourceId?: string; }) {
        return DefaultApiFp.findUGC(params)(this.fetch, this.basePath);
    }
    /** 
     * Get types of user generated content.
     * Method returns types of user generated content.
     */
    getContentTypes() {
        return DefaultApiFp.getContentTypes()(this.fetch, this.basePath);
    }
    /** 
     * Get location types of user generated content.
     * Method returns location types of user generated content.
     */
    getLocationTypes() {
        return DefaultApiFp.getLocationTypes()(this.fetch, this.basePath);
    }
    /** 
     * Get user generated content by UGC ID
     * Method returns the user generated content by UGC id.
     * @param ugcId UGC ID
     */
    getUGC(params: {  ugcId: string; }) {
        return DefaultApiFp.getUGC(params)(this.fetch, this.basePath);
    }
    /** 
     * Remove user generated content
     * Remove user generated content by UGC ID.
     * @param ugcId UGC ID
     */
    removeUGC(params: {  ugcId: string; }) {
        return DefaultApiFp.removeUGC(params)(this.fetch, this.basePath);
    }
    /** 
     * Update user generated content
     * Update user generated content by UGC ID.
     * @param ugcId UGC ID
     * @param body Generated content object
     */
    updateUGC(params: {  ugcId: string; body: GeneratedContentRequest; }) {
        return DefaultApiFp.updateUGC(params)(this.fetch, this.basePath);
    }
}

