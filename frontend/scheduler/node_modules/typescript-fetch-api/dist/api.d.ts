export interface FetchAPI {
    (url: string, init?: any): Promise<any>;
}
export interface FetchArgs {
    url: string;
    options: any;
}
export declare class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    constructor(fetch?: FetchAPI, basePath?: string);
}
export interface BookmarkFixedDto extends BookmarkLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}
export interface BookmarkLocationDto {
}
export interface BookmarkReflowDto extends BookmarkLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}
export interface BookmarkRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": BookmarkLocationDto;
    /**
     * Text value
     */
    "text": string;
}
export interface BookmarkResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": BookmarkLocationDto;
    /**
     * Text value
     */
    "text": string;
}
export interface ContentLocationDto {
    /**
     * Resource id, the same value as contentId
     */
    "resourceId": string;
}
export interface EmpiriaContentRequest extends GeneratedContentRequest {
    /**
     * Text value
     */
    "text": string;
    "location": ContentLocationDto;
}
export interface EmpiriaContentResponse extends GeneratedContentResponse {
    /**
     * Text value
     */
    "text": string;
    "location": ContentLocationDto;
}
export interface EmpiriaHotspotRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": HotspotLocationDto;
    /**
     * Content value
     */
    "content": string;
}
export interface EmpiriaHotspotResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": HotspotLocationDto;
    /**
     * Content value
     */
    "content": string;
}
export interface GeneratedContentRequest {
    "location": Location;
    /**
     * Content type: bookmark, html content, html hotspot, text field, last visited page, teacher panel, note, empiria content, empiria hotspot, highlight
     */
    "type": string;
    /**
     * Resource ID
     */
    "resourceId": string;
}
export interface GeneratedContentResponse {
    /**
     * Unique UGC ID
     */
    "id": string;
    /**
     * User ID
     */
    "userId": string;
    /**
     * Last modification date-time
     */
    "modificationDate"?: Date;
    "location": Location;
    /**
     * Content type: bookmark, html content, html hotspot, text field, last visited page, teacher panel, note, empiria content, empiria hotspot, highlight
     */
    "type": string;
    /**
     * Resource ID
     */
    "resourceId": string;
}
export interface HighlightFixedDto extends HighlightLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
    /**
     * Highlight starting index
     */
    "startIndex": number;
    /**
     * Highlight ending index
     */
    "endIndex": number;
}
export interface HighlightLocationDto {
}
export interface HighlightReflowDto extends HighlightLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Paragraph location
     */
    "paragraphPosition": number;
    /**
     * Highlight starting index
     */
    "startIndex": number;
    /**
     * Highlight ending index
     */
    "endIndex": number;
}
export interface HighlightRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": HighlightLocationDto;
}
export interface HighlightResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": HighlightLocationDto;
}
export interface HotspotLocationDto {
    /**
     * Hotspot ID
     */
    "hotspotId": string;
}
export interface HtmlContentRequest extends GeneratedContentRequest {
    /**
     * Text value
     */
    "text": string;
    "location": ContentLocationDto;
}
export interface HtmlContentResponse extends GeneratedContentResponse {
    /**
     * Text value
     */
    "text": string;
    "location": ContentLocationDto;
}
export interface HtmlHotspotRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": HotspotLocationDto;
    /**
     * Content value
     */
    "content": string;
}
export interface HtmlHotspotResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": HotspotLocationDto;
    /**
     * Content value
     */
    "content": string;
}
export interface LastVisitedPageFixedDto extends LastVisitedPageLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}
export interface LastVisitedPageLocationDto {
}
export interface LastVisitedPageReflowDto extends LastVisitedPageLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}
export interface LastVisitedPageRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": LastVisitedPageLocationDto;
}
export interface LastVisitedPageResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": LastVisitedPageLocationDto;
}
export interface Location {
}
export interface NoteFixedDto extends NoteLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
    /**
     * X position on the page
     */
    "x": number;
    /**
     * Y position on the page
     */
    "y": number;
}
export interface NoteLocationDto {
}
export interface NoteReflowDto extends NoteLocationDto {
    "paragraph"?: any;
    /**
     * Char position where note should be displayed
     */
    "charPosition": number;
    /**
     * Type of location
     */
    "type": string;
}
export interface NoteRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": NoteLocationDto;
    /**
     * Content value
     */
    "text": string;
    /**
     * Text colour
     */
    "colour": NoteRequestColourEnum;
    /**
     * Text style
     */
    "textStyle": NoteRequestTextStyleEnum;
}
export declare type NoteRequestColourEnum = "WHITE" | "BLACK" | "GREEN" | "BLUE" | "RED" | "YELLOW" | "PINK" | "VIOLET";
export declare type NoteRequestTextStyleEnum = "BOLD" | "ITALIC" | "UNDERGROUND";
export interface NoteResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": NoteLocationDto;
    /**
     * Content value
     */
    "text": string;
    /**
     * Text colour
     */
    "colour": NoteResponseColourEnum;
    /**
     * Text style
     */
    "textStyle": NoteResponseTextStyleEnum;
}
export declare type NoteResponseColourEnum = "WHITE" | "BLACK" | "GREEN" | "BLUE" | "RED" | "YELLOW" | "PINK" | "VIOLET";
export declare type NoteResponseTextStyleEnum = "BOLD" | "ITALIC" | "UNDERGROUND";
export interface PointDto {
    /**
     * X position
     */
    "x": number;
    /**
     * Y position
     */
    "y": number;
}
export interface TeacherPanelContentDto {
    /**
     * Tool name
     */
    "toolName": TeacherPanelContentDtoToolNameEnum;
    /**
     * Shape points
     */
    "points": Array<PointDto>;
    /**
     * Transformation matrix
     */
    "transform": {
        [key: string]: string;
    };
    /**
     * Fill color
     */
    "fillColor": TeacherPanelContentDtoFillColorEnum;
    /**
     * Line color
     */
    "lineColor": TeacherPanelContentDtoLineColorEnum;
    /**
     * Line weight
     */
    "lineWeight": number;
    /**
     * Alpha
     */
    "alpha": number;
    /**
     * Contour
     */
    "contour"?: TeacherPanelContentDtoContourEnum;
}
export declare type TeacherPanelContentDtoToolNameEnum = "ELLIPSE" | "MARK" | "PEN" | "SHADE" | "TRIANGLE" | "LINE" | "MARKER" | "RECTANGLE" | "ARROW";
export declare type TeacherPanelContentDtoFillColorEnum = "WHITE" | "BLACK" | "GREEN" | "BLUE" | "RED" | "YELLOW" | "PINK" | "VIOLET";
export declare type TeacherPanelContentDtoLineColorEnum = "WHITE" | "BLACK" | "GREEN" | "BLUE" | "RED" | "YELLOW" | "PINK" | "VIOLET";
export declare type TeacherPanelContentDtoContourEnum = "FILL" | "OUTLINE";
export interface TeacherPanelFixedDto extends TeacherPanelLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}
export interface TeacherPanelLocationDto {
}
export interface TeacherPanelReflowDto extends TeacherPanelLocationDto {
    /**
     * Type of location
     */
    "type": string;
    /**
     * Location, that could be anything we use for determining position: page number, or location based on characters
     */
    "pageIndex": number;
}
export interface TeacherPanelRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": TeacherPanelLocationDto;
    /**
     * Content value
     */
    "content": Array<TeacherPanelContentDto>;
}
export interface TeacherPanelResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": TeacherPanelLocationDto;
    /**
     * Content value
     */
    "content": Array<TeacherPanelContentDto>;
}
export interface TextfieldLocationDto {
    /**
     * Hotspot ID
     */
    "hotspotId": string;
}
export interface TextfieldRequest extends GeneratedContentRequest {
    /**
     * Location determined by content type
     */
    "location": TextfieldLocationDto;
    /**
     * Text value
     */
    "text": string;
}
export interface TextfieldResponse extends GeneratedContentResponse {
    /**
     * Location determined by content type
     */
    "location": TextfieldLocationDto;
    /**
     * Text value
     */
    "text": string;
}
/**
 * DefaultApi - fetch parameter creator
 */
export declare const DefaultApiFetchParamCreactor: {
    createUGC(params: {
        body: GeneratedContentRequest;
    }): FetchArgs;
    findUGC(params: {
        resourceId?: string;
    }): FetchArgs;
    getContentTypes(): FetchArgs;
    getLocationTypes(): FetchArgs;
    getUGC(params: {
        ugcId: string;
    }): FetchArgs;
    removeUGC(params: {
        ugcId: string;
    }): FetchArgs;
    updateUGC(params: {
        ugcId: string;
        body: GeneratedContentRequest;
    }): FetchArgs;
};
/**
 * DefaultApi - functional programming interface
 */
export declare const DefaultApiFp: {
    createUGC(params: {
        body: GeneratedContentRequest;
    }): (fetch: FetchAPI, basePath?: string) => Promise<any>;
    findUGC(params: {
        resourceId?: string;
    }): (fetch: FetchAPI, basePath?: string) => Promise<GeneratedContentResponse[]>;
    getContentTypes(): (fetch: FetchAPI, basePath?: string) => Promise<string[]>;
    getLocationTypes(): (fetch: FetchAPI, basePath?: string) => Promise<string[]>;
    getUGC(params: {
        ugcId: string;
    }): (fetch: FetchAPI, basePath?: string) => Promise<GeneratedContentResponse>;
    removeUGC(params: {
        ugcId: string;
    }): (fetch: FetchAPI, basePath?: string) => Promise<any>;
    updateUGC(params: {
        ugcId: string;
        body: GeneratedContentRequest;
    }): (fetch: FetchAPI, basePath?: string) => Promise<any>;
};
/**
 * DefaultApi - object-oriented interface
 */
export declare class DefaultApi extends BaseAPI {
    /**
     * Create new user generated content
     * Save user generated content.
     * @param body Generated content object
     */
    createUGC(params: {
        body: GeneratedContentRequest;
    }): Promise<any>;
    /**
     * Get user generated content by resource ID
     * Method returns the user generated content by resource id.
     * @param resourceId Resource ID
     */
    findUGC(params: {
        resourceId?: string;
    }): Promise<GeneratedContentResponse[]>;
    /**
     * Get types of user generated content.
     * Method returns types of user generated content.
     */
    getContentTypes(): Promise<string[]>;
    /**
     * Get location types of user generated content.
     * Method returns location types of user generated content.
     */
    getLocationTypes(): Promise<string[]>;
    /**
     * Get user generated content by UGC ID
     * Method returns the user generated content by UGC id.
     * @param ugcId UGC ID
     */
    getUGC(params: {
        ugcId: string;
    }): Promise<GeneratedContentResponse>;
    /**
     * Remove user generated content
     * Remove user generated content by UGC ID.
     * @param ugcId UGC ID
     */
    removeUGC(params: {
        ugcId: string;
    }): Promise<any>;
    /**
     * Update user generated content
     * Update user generated content by UGC ID.
     * @param ugcId UGC ID
     * @param body Generated content object
     */
    updateUGC(params: {
        ugcId: string;
        body: GeneratedContentRequest;
    }): Promise<any>;
}
